<html>
	<head>
		<title>ED Galaxy Map</title>
        <link href="js/select2.css" rel="stylesheet" />
		<style>
            body 
            {
	            font-family: Monospace;
	            font-weight: bold;	            
	            margin: 0px;
	            overflow: hidden;
                background-color: black;
            }
            canvas { width: 100%; height: 100% }
            #controls
            {
              /*background-color: black;*/
              top: 0px;
              left: 10px;
              position: absolute;
              width: 100%;
              color: white;
              z-index:5;
            }
            #left
            {
              width: 300px;
              float: left;
              
            }
            #right
            {
              margin-left: 300px; /* Change this to whatever the width of your left column is ALSO change var windowOffset below */
            }
            .clear
            {
              clear: both;
            }
            .hidden 
            {
                display: none;
            }
        </style>
	</head>
	<body>

        <div id="container">
            <div id="left">



                <div id="controls">
                    <br /><label>Left Mouse: Hold to Rotate. Right Mouse: Pan. Mouse Wheel: Zoom</label>
                    <br /><label>Use left mouse or dropdown to build a route.</label>
                    <br />

                    <button id="tabButtonPlan" class="tabButton">Plan</button>
                    <button id="tabButtonHistory" class="tabButton">History</button>
                    <button id="tabButtonHeatmap" class="tabButton">Heatmap</button>
                    <button id="tabButtonUtils" class="tabButton">Utils</button>

                    <div id="tabPanelPlan" class="tabPanel hidden">
                        <br /><label>Find Shortest Route will find route between first and second selected systems.</label>
                        <!--<br />Select System:<select id="ddlSystems"><option></option></select>-->
                        <br /><input type="hidden" id="ddlSystemsHidden" />
                        <br /><button id="btnMoreSystems">Debugging Button</button>
                        <br /><button id="btnClearRoute">Clear Route</button>

                        <br /><button id="btnShortestRoute">Find Shortest Route using this jump distance:</button><input id="maxJumpDistance" type="text" style="width:40px;" value="7" />
                        <br /><label id="label1">Info:</label><label id="labelInfo"></label>
                        <br /><label id="label2">Route:</label><label id="labelRoute"></label>
                        <br /><label id="label3">Distance:</label><label id="labelDistance"></label>
                        <br /><input type="checkbox" id="chkShowOnlyRouteSystems" />Show only Route Systems
                    </div>
                    <div id="tabPanelHistory" class="tabPanel hidden">
                        Coming soon!
                    </div>
                    <div id="tabPanelHeatmap" class="tabPanel hidden">
                        Coming soon!

                    </div>
                    <div id="tabPanelUtils" class="tabPanel hidden">
                        <br /><button id="btnDistanceDump">Distance Dump</button>
                        <br /><textarea id="txtDistances" rows="4" cols="50" style="display:none;"></textarea>
                    </div>
                </div>
            </div>
            <div id="right">
                <div id="renderContainer">

                </div>                
            </div>
            <div class="clear"></div>
        </div>

        <script src="js/jquery-2.1.1.min.js"></script>
		<script src="js/three.min.js"></script>
        <script src="js/controls/TrackballControls.js"></script>
		<script src="js/controls/OrbitControls.js"></script>

        <script src="js/Detector.js"></script>
		<script src="js/KeyboardState.js"></script>
        <script src="js/libs/stats.min.js"></script>
		<script src="js/underscore-min.js"></script>			
		<script src="gamma-data.js"></script>
        
        <script src="js/dijkstra-master/graph.js"></script>		        
        <script src="js/select2.min.js"></script>

        <!-- load the font files -->

        <script src="fonts/gentilis_bold.typeface.js"></script>
        <script src="fonts/gentilis_regular.typeface.js"></script>
        <script src="fonts/optimer_bold.typeface.js"></script>
        <script src="fonts/optimer_regular.typeface.js"></script>
        <script src="fonts/helvetiker_bold.typeface.js"></script>
        <script src="fonts/helvetiker_regular.typeface.js"></script>
        <script src="fonts/droid/droid_sans_regular.typeface.js"></script>
        <script src="fonts/droid/droid_sans_bold.typeface.js"></script>
        <script src="fonts/droid/droid_serif_regular.typeface.js"></script>
        <script src="fonts/droid/droid_serif_bold.typeface.js"></script>

		<script>
            // Handler for .ready() called.            
            $(function () {

                $("#btnMoreSystems").click(function () {

                    setTimeout(function () {
                        
                        //var query = {
					    //    ver:2, 
					    //    test:true,
					    //    outputmode:2, 
					    //    filter:{
					    //        knownstatus:0,
					    //        //systemname: "sol",
					    //        cr:5,
					    //        date:"2014-09-18 12:34:56",
					    //        coordcube: [[-10,10],[-10,10],[-10,10]],
					    //        coordsphere: {radius: 123.45, origin: [10,20,30]}
					    //    }
					    //};


                        //$.ajax({
                        //type: 'POST',
                        //contentType: 'application/json; charset=utf-8',
                        //url: 'http://edstarcoordinator.com/api.asmx/GetSystems',
                        //data: JSON.stringify(query),
                        //dataType: 'json',
                        //success:
                        //    function (data) {
                        //    var f = '';
                        //    },
                        //error:
    	                //    function (d,a){
    		            //        var ss = '';
    	                //    }	 
                        //});



                        $.ajax({
                            type: 'GET',
                            contentType: 'application/json; charset=utf-8',
                            //url: 'http://adamapi:api123adam@010102.de/external/heatmap',
                            url: 'http://010102.de/external/heatmap',
                            //data: JSON.stringify(query),
                            dataType: 'json',
                            username: 'adamapi',
                            password: 'api123adam',
                            crossDomain: true,
                            xhrFields: {
                                withCredentials: true
                            },
                            success:
                                function (data) {
                                    var f = '';
                                },
                            error:
                                function (d, a) {
                                    var ss = '';
                                }
                        });







                    }, 100)
                    $("#btnMoreSystems").hide();
                });

                $("#btnClearRoute").click(function () {
                    clearRoute();
                });

                $("#btnShortestRoute").click(function () {
                    var maxDist = $('#maxJumpDistance').val();
                    megaShortestRoute(maxDist);
                });

                $("#btnDistanceDump").click(function () {
                    var distances = distanceTextDump();
                    $("#txtDistances").show();
                    $("#txtDistances").val(distances);
                    $("#btnDistanceDump").hide();
                });

                $("#ddlSystemsHidden").change(function (e) {
                    var systemName = e.val;
                    applySelectionToSystem(selectionInfo, systemName, routeSelectionMaterial);
                });

                $('.tabButton').click(function () {
                    handleTabClick($(this).attr('id'));
                });

                $('#chkShowOnlyRouteSystems').click(function () {
                    showOnlyRouteSystems($(this).is(':checked'));
                });

            });

            // Todo list
            // Done. Enable selection of a system
            // Done. Enable selection of 2 systems, then display distance between them
            // Done. Add dropdowns to allow selection of systems

            // Switch to use EDStarCoordinator API to return list of systems within a sphere of current system
            // Only display those items within sphere
            // DONE POINTCLOUD:Or try generate a point cloud for a larger (all?) amount of items, and then switch to generating spheres + names within some radius
            // DONE: WILL def need to use a point cloud
            // Need to be able to make camera focus on a selected item
            // The selected item being your current system, which it obtains from the NetLog (just use another program to get that info??)

            var windowOffset = 300; // this must match the css width values above in #left and #right

            var resolvedSystems = [];
            var xyzData = [];
            var lines = [];
			var container, stats;
			var camera, controls, scene, renderer;			
			var projector, mouse = { x: 0, y: 0 };

			var selectionInfo = {
                currentIntersectingObject: {},
                routeSelections: [],
                currentRoute: []
			};

			var scale = 10;
			var unselectedColor = 0xffffff;
			var hoverColor = 0xffff00;
			var routeSelectionColor = 0xff69b4;
			var unselectedMaterial = new THREE.MeshLambertMaterial({ color: unselectedColor, shading: THREE.FlatShading });
			var hoverMaterial = new THREE.MeshLambertMaterial({ color: hoverColor, shading: THREE.FlatShading });
			var routeSelectionMaterial = new THREE.MeshLambertMaterial({ color: routeSelectionColor, shading: THREE.FlatShading });
			var sphereGeometry = new THREE.SphereGeometry(3,4,4);

			var keyboard = new KeyboardState();
			var ctrlPressed = false;
			var shiftPressed = false;


			handleTabClick('tabButtonPlan');

			init();
			animate();

			function handleTabClick(tabId) {
			    var tabButtons = $('.tabButton');
			    var tabPanels = $('.tabPanel');

			    var panelId = tabId.replace('tabButton', 'tabPanel');
			    tabPanels.hide();
			    $('#' + panelId).show();
			}

			function init() {

				xyzData = readXyzData();

				scene = new THREE.Scene();
                				
				initCamera(scene);
				initScene(scene);
				
				addSysInfoPointCloudToScene(scene, xyzData);
				initControls(camera);
				initRenderer();
				initHandlers();
				
				$('#ddlSystemsHidden').select2({
                    width: 300,
				    placeholder: 'Select a System',
				    minimumInputLength: 2,
				    query: function (query) {
				        var sorted = _.sortBy(xyzData, function (o) { return o.system; });
				        var data = { results: [] };
				        var queryTerm = query.term.toLowerCase();
				        for (var i = 0; i < sorted.length; i++) {
				            var current = sorted[i].system;
				            if (current.toLowerCase().indexOf(queryTerm) == 0) {
				                data.results.push({ id: current, text: current });
				            }
				        }
				        query.callback(data);
				    }
				});

			}

			function animate() {
			    requestAnimationFrame(animate);
			    update();
			    render();
			    controls.update();
			}

			function initCamera(scene) {
			    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 100000);
			    scene.add(camera);

			    camera.position.z = 600;
			    camera.position.y = 700;
			    camera.position.x = -100;

			    camera.lookAt(scene.position);    
			}

			//function addSysInfoToDropDown(sysInfo, ddl) {
			//    var sorted = _.sortBy(sysInfo, function (o) { return o.system; });

			//    $.each(sorted, function (index, value) {
			//        $(ddl).append($('<option/>', { value: value.system, text: value.system }));
			//    });
			//}

			function generatePointCloudGeometry( color, sysInfo ){

				var geometry = new THREE.BufferGeometry();
				var numPoints = sysInfo.length;

				var positions = new Float32Array( numPoints*3 );
				var colors = new Float32Array( numPoints*3 );

				for( var i = 0; i < sysInfo.length; i++ ) {

					var u = 1;
					var v = 1;
					var x = (sysInfo[i].x) * scale;
					var y = (sysInfo[i].y) * scale;
					var z = (sysInfo[i].z) * scale;

					positions[ i ] = x;
					positions[ i + 1 ] = y;
					positions[ i + 2 ] = z;
					
					colors[ i ] = color.r;
					colors[ i + 1 ] = color.r;
					colors[ i + 2 ] = color.r;					

				}

				

				geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
				geometry.computeBoundingBox();

				return geometry;

			}

			function addSysInfoPointCloudToScene(scene, sysInfo) {
				var geometry = generatePointCloudGeometry(new THREE.Color( 1,0,0 ), sysInfo);
				var material = new THREE.PointCloudMaterial( { size: 0.05, vertexColors: THREE.VertexColors } );
				var pointcloud = new THREE.PointCloud( geometry, material );

				pointcloud.scale.set(1,1,1);
				pointcloud.position.set(0,0,0);
				scene.add(pointcloud); 		

			}

			function addSysInfoToScene(scene, sysInfo) {			    

			    var maxItems = sysInfo.length;
			    //var maxItems = 100; // limiting the number of fully rendered items

			    for (var i = 0; i < maxItems; i++) {

			    	addSingleSystemToScene(scene, sysInfo[i]);			        
			    }
			}

			function addSingleSystemToScene(scene, singleSystem) {

			    var material = unselectedMaterial;

		        var mesh = new THREE.Mesh(sphereGeometry, material);
		        mesh.position.x = (singleSystem.x) * scale;
		        mesh.position.y = (singleSystem.y) * scale;
		        mesh.position.z = (singleSystem.z) * scale;
		        mesh.updateMatrix();
		        mesh.matrixAutoUpdate = false;
		        mesh.sysInfo = singleSystem;
		        mesh.meshType = 'sphere';

		        scene.add(mesh);

                // Billboard sprites for names. 
		        //var spritey = makeTextSprite(sysInfo[i].system,
                //    {
                //        fontsize: 32,
                //        fontface: "Georgia",
                //        borderColor: { r: 0, g: 0, b: 255, a: 1.0 }
                //    });
		        //spritey.position.set(sysInfo[i].x * scale, sysInfo[i].y * scale, sysInfo[i].z * scale);
		        //spritey.sysInfo = sysInfo[i];
		        //scene.add(spritey);


                // real 3d objects for names
		        var textOptions = {
		            size: 10,
		            height: 1,
                    curveSegments: 2
		        };
		        var label = new THREE.TextGeometry(singleSystem.system, textOptions);
		        var labelMesh = new THREE.Mesh(label, material);
		        labelMesh.position.x = (singleSystem.x) * scale;
		        labelMesh.position.y = (singleSystem.y - 2) * scale;
		        labelMesh.position.z = (singleSystem.z) * scale;
		        labelMesh.updateMatrix();
		        //labelMesh.matrixAutoUpdate = false;
		        labelMesh.sysInfo = singleSystem;
		        labelMesh.meshType = 'text';

		        mesh.sisterMesh = labelMesh;
		        labelMesh.sisterMesh = mesh;

		        scene.add(labelMesh);
			}

			function initScene(scene) {
			    // world

			    var gridXZ = new THREE.GridHelper(1000, 200);
			    gridXZ.setColors(new THREE.Color(0xf5f5f5), new THREE.Color(0xf5f5f5));
			    gridXZ.position.set(0, 0, 0);
			    scene.add(gridXZ);
			    

			    // lights
			    light = new THREE.DirectionalLight(0xffffff);
			    light.position.set(1, 1, 1);
			    scene.add(light);

			    light = new THREE.DirectionalLight(0xffffff);
			    light.position.set(-1, -1, -1);
			    scene.add(light);

			    //light = new THREE.AmbientLight(0xffffff);
			    light = new THREE.AmbientLight(0x222222);
			    scene.add(light);

			    // initialize object to perform world/screen calculations
			    projector = new THREE.Projector();

			}

			function initControls(camera) {
			    //initTrackballControls(camera);
			    initOrbitControls(camera);
			}

			function initTrackballControls(camera) {
			    controls = new THREE.TrackballControls(camera);

			    controls.rotateSpeed = 1.0;
			    controls.zoomSpeed = 1.2;
			    controls.panSpeed = 0.8;

			    controls.noZoom = false;
			    controls.noPan = false;

			    controls.staticMoving = true;
			    controls.dynamicDampingFactor = 0.3;

			    controls.keys = [65, 83, 68];

			    controls.addEventListener('change', render);
			}

			function initOrbitControls(camera) {
			    controls = new THREE.OrbitControls(camera);
			    controls.damping = 0.2;
			    controls.addEventListener('change', render);
			}

			function initRenderer() {
			    container = document.getElementById('renderContainer');

			    renderer = new THREE.WebGLRenderer({ antialias: false });			    
			    renderer.setSize(container.offsetWidth, window.innerHeight);

			    
			    container.appendChild(renderer.domElement);

			    stats = new Stats();
			    stats.domElement.style.position = 'absolute';
			    stats.domElement.style.top = '0px';
			    stats.domElement.style.right = '0px';
			    stats.domElement.style.zIndex = 100;
			    container.appendChild(stats.domElement);
			}

			function initHandlers() {
			    // when the mouse moves, call the given function
			    document.addEventListener('mousemove', onDocumentMouseMove, false);
			    document.addEventListener('mousedown', onDocumentMouseDown, false);

			    window.addEventListener('resize', onWindowResize, false);
			}

			function onDocumentMouseDown(event) {		    
			    
			    handlePossibleSelection();
			}

			function onDocumentMouseMove(event) {
			    // the following line would stop any other event handler from firing
			    // (such as the mouse's TrackballControls)
			    // event.preventDefault();

			    // update the mouse variable
			    //mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			    //mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                		    

			    mouse.x = (((event.clientX - windowOffset) / container.offsetWidth)) * 2 - 1;
			    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
			    
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				//controls.handleResize();
			}

			function update() {

			    keyboard.update();

			    ctrlPressed = keyboard.pressed("ctrl");
			    shiftPressed = keyboard.pressed("shift");


			    setColor(selectionInfo.currentIntersectingObject, unselectedMaterial);

			    $.each(selectionInfo.routeSelections, function (index, value) {
			        setColor(selectionInfo.routeSelections[index], routeSelectionMaterial);
			    });

			    $.each(scene.children, function (index, value) {
			        if (value.meshType == 'text') {
                        // This will force the text to always face the viewer, but I am not sure I like it
			            //value.lookAt(camera.position);
			        }
			    });

			    newIntersectingObject = firstIntersectingObject();

			    if (newIntersectingObject) {
			        // set the hover color for the object the person has moused over
			        setColor(newIntersectingObject, hoverMaterial);
			        selectionInfo.currentIntersectingObject = newIntersectingObject;

			    } else {
			        selectionInfo.currentIntersectingObject = null;
			    }
			}

			function firstIntersectingObject() {
			    // find intersections
			    // create a Ray with origin at the mouse position and direction into the scene (camera direction)
			    var vector = new THREE.Vector3(mouse.x, mouse.y, 1);
			    projector.unprojectVector(vector, camera);
			    var ray = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());

			    // create an array containing all objects in the scene with which the ray intersects
			    var intersects = ray.intersectObjects(scene.children);

			    // if there is one (or more) intersections
			    if (intersects.length > 0) {
			        // if the closest object intersected has sysInfo (ie we want to be able to select it)
			        if (intersects[0].object.sysInfo) {
			            return intersects[0].object;
			        }
			    }
			    return null;
			}

			function showOnlyRouteSystems(show) {
			    if (show) {
			        $.each(scene.children, function (index, value) {
			            if ((value.meshType && (value.meshType == 'sphere' || value.meshType == 'text'))) {
			                value.visible = false;
			            }
			        });

			        $.each(selectionInfo.currentRoute, function (index, value) {
			            var foundInScene = findSystemInScene(value);
			            if (foundInScene != null) {
			                foundInScene.visible = true;
			            }
			            var foundInScene = findSystemTextInScene(value);
			            if (foundInScene != null) {
			                foundInScene.visible = true;
			            }
			        });
			    } else {
			        $.each(scene.children, function (index, value) {
			            if ((value.meshType && (value.meshType == 'sphere' || value.meshType == 'text'))) {
			                value.visible = true;
			            }
			        });
			    }
			}

            function applySelectionToSystem(selectionInfo, systemName, selectionMaterial) {
            	ensureProximalObjectsCreated(systemName);
                selectSceneObject(selectionInfo, systemName, selectionMaterial);
                displayDistance();
                displayRoute();
            }

            function ensureProximalObjectsCreated(systemName) {
				
            	var current = _.find(xyzData, function(o){ return o.system == systemName});	
            	
            	var sphere = new THREE.Sphere(new THREE.Vector3(current.x, current.y, current.z), 30);

            	$.each(xyzData, function(index, value) {
            		if (sphere.containsPoint(new THREE.Vector3(value.x,value.y,value.z))) {
            			var foundInScene = findSystemInScene(value.system);
            			if (foundInScene == null) {
            				resolvedSystems.push(value);
							addSingleSystemToScene(scene, value);
            			} else {
            			    foundInScene.visible = true;
            			    var text = findSystemTextInScene(value.system);
            			    text.visible = true;
            			}
            		}
            	});
            }

            function displayRoute() {
                var totalRoute = '';
                $.each(selectionInfo.routeSelections, function (index, value) {
                    totalRoute += selectionInfo.routeSelections[index].sysInfo.system + ' -> ';
                });

                var trimmed = totalRoute.substring(0, totalRoute.length - 4);
                $('#labelRoute').text(trimmed);
            }

            function displayDistance() {
                
                var totalDistance = 0;
                $.each(selectionInfo.routeSelections, function (index, value) {
                    if (selectionInfo.routeSelections.length > 1 && index < selectionInfo.routeSelections.length-1) {
                        var d = calculateDistance(selectionInfo.routeSelections[index].sysInfo, selectionInfo.routeSelections[index + 1].sysInfo);
                        totalDistance += +d;
                    }
                });

                $('#labelDistance').text(totalDistance.toFixed(2));
            }

            function megaShortestRoute(maxJumpDistance) {

                ensureSystemsInPathArePopulated();

                findShortestRoute(maxJumpDistance)
                
            }

            function ensureSystemsInPathArePopulated() {

                var endpointReached = false;

                var start = selectionInfo.routeSelections[0].sysInfo;
                var destination = selectionInfo.routeSelections[1].sysInfo;
                var destVec = new THREE.Vector3(destination.x, destination.y, destination.z)

                var currentPathCentre = start;                

                while (!endpointReached) {
                    var sphere = new THREE.Sphere(new THREE.Vector3(currentPathCentre.x, currentPathCentre.y, currentPathCentre.z), 40);
                    var currentSystemsInScene = getSystemsInScene();
                    var currentSmallestDistance = 999999999;

                    $.each(currentSystemsInScene, function (index, value) {
                        var vec = new THREE.Vector3(value.sysInfo.x, value.sysInfo.y, value.sysInfo.z);

                        if (sphere.containsPoint(vec)) {
                            var dist = vec.distanceTo(destVec);
                            if (dist < currentSmallestDistance) {
                                currentSmallestDistance = dist;
                                currentPathCentre = value.sysInfo;                                
                            }
                        }

                        if (sphere.containsPoint(destVec)) {
                            endpointReached = true;
                        }
                    });

                    // Now we resolve a new set of systems around the selected one
                    ensureProximalObjectsCreated(currentPathCentre.system);
                }
            }

            function findShortestRoute(maxJumpDistance) {

                maxJumpDistance = +maxJumpDistance; // force to int
	            var currentDistanceCheck = maxJumpDistance;
	            var numberOfAttempts = 10;
	            var found = false;

	            for (var i = 0; i < numberOfAttempts; i++) {		            
		            if (calcShortestRoute(currentDistanceCheck)) {
			            found = true;
			            break;
		            }
		            currentDistanceCheck = maxJumpDistance + i;
	            }

	            if (found) {
		            if (currentDistanceCheck != maxJumpDistance) {
    		            $('#labelInfo').text('Could not make trip with ' + maxJumpDistance + 'LY jump, but found a route with ' + currentDistanceCheck + 'LY jumps');
        	            //$('#labelDistance').text("");
		            } else {
		                $('#labelInfo').text('Route found.');
		                displayDistance();
		                displayRoute();
		            }

	            } else {
    	            $('#labelRoute').text('Cannot make this trip');
    	            $('#labelDistance').text("");
	            }

            }

            function calcShortestRoute(maxJumpDistance) {

                if (selectionInfo.routeSelections[0] && selectionInfo.routeSelections[1]) {

                    var distanceDump = distanceDumper(resolvedSystems);
                    if (!maxJumpDistance) {
                        maxJumpDistance = 7; // Max distance your ship can jump
                    }
                    
                    var map = buildMap(distanceDump, +maxJumpDistance);

                    var graph = new Graph(map);
                
                    var shortestPath = graph.findShortestPath(selectionInfo.routeSelections[0].sysInfo.system, selectionInfo.routeSelections[1].sysInfo.system);

                    if (shortestPath) {
                        $('#labelRoute').text(shortestPath);
                        var distances = getDistancesForShortestRoute(distanceDump, shortestPath);
                        $('#labelDistance').text(distances);

                        drawLinesForShortestPath(shortestPath);
                        selectionInfo.currentRoute = shortestPath;
                        return true;
                    } else {
                    	return false;
                    }
                }
            }

            function drawLinesForShortestPath(shortestPath) {
                // experimental line drawing
                var material = new THREE.LineBasicMaterial({
                    color: 0xff69b4
                });

                for (var i = 0; i < shortestPath.length - 1; i++) {
                    var geometry = new THREE.Geometry();                    

                    for (var j = 0; j < scene.children.length; j++) {
                        if (scene.children[j].meshType && scene.children[j].meshType == 'sphere' && scene.children[j].sysInfo.system == shortestPath[i]) {
                            geometry.vertices.push(scene.children[j].position);
                        }
                    }

                    for (var k = 0; k < scene.children.length; k++) {
                        if (scene.children[k].meshType && scene.children[k].meshType == 'sphere' && scene.children[k].sysInfo.system == shortestPath[i + 1]) {
                            geometry.vertices.push(scene.children[k].position);
                        }
                    }

                    var line = new THREE.Line(geometry, material);
                    line.meshType = 'line';
                    scene.add(line);
                }
            }

            function getDistancesForShortestRoute(distanceDump, shortestPath) {
                var distances = [];
                for (var i = 0; i < shortestPath.length-1; i++) {
                    for (var j = 0; j < distanceDump.length; j++) {
                        if (distanceDump[j].systemFrom == shortestPath[i] && distanceDump[j].systemTo == shortestPath[i+1]) {
                            distances.push(distanceDump[j].distance);
                            break;
                        }
                    }
                }
                return distances.join();
            }

            function buildMap(distanceDump, maxJumpDistance) {
                var map = {};
                for (var i = 0; i < distanceDump.length; i++) {
                    var dd = distanceDump[i];
                    var from = dd.systemFrom;
                    var to = dd.systemTo;
                    var d = +dd.distance;

                    if (d <= maxJumpDistance) {
                        var obj = {};
                        obj[to] = d
                        var res = $.extend(true, map[from], obj);
                        map[from] = res;
                    }
                }
                return map;
            }

            function distanceDumper(systemsToProcess) {
                var dump = [];                

                for (var i = 0; i < systemsToProcess.length; i++) {
                    for (var j = 0; j < systemsToProcess.length; j++) {
                        var d = calculateDistance(systemsToProcess[i], systemsToProcess[j]);
                        dump.push({ "systemFrom": systemsToProcess[i].system, "systemTo": systemsToProcess[j].system, "distance": d.toFixed(2) });
                    }
                }
                return dump;
            }

            function distanceTextDump() {
                var distanceDump = distanceDumper(resolvedSystems);
                var dump = '';

                for (var i = 0; i < distanceDump.length; i++) {
                    dump += distanceDump[i].systemFrom + ',' + distanceDump[i].systemTo + ',' + distanceDump[i].distance + '\n';
                }
                return dump;
            }

            function getSystemsInScene() {
                var toReturn = [];
                $.each(scene.children, function (index, value) {
                    if (value.meshType == 'sphere') {
                        toReturn.push(value);                        
                    }
                });
                return toReturn;
            }

            function findSystemInScene(systemName) {
            	var toReturn = null;
				$.each(scene.children, function (index, value) {
                    if (value.meshType == 'sphere' && value.sysInfo.system == systemName) {
                        toReturn = value;
                        return false;
                    }
                });
                return toReturn;            	
            }

            function findSystemTextInScene(systemName) {
                var toReturn = null;
                $.each(scene.children, function (index, value) {
                    if (value.meshType == 'text' && value.sysInfo.system == systemName) {
                        toReturn = value;
                        return false;
                    }
                });
                return toReturn;
            }

            function selectSceneObject(selectionInfo, systemName, selectionMaterial) {
            	var found = findSystemInScene(systemName);
            	if (found != null) {
            		setSelectionObject(selectionInfo, found, selectionMaterial);
            	}                
            }

            function setSelectionObject(selectionInfo, object, material) {
                selectionInfo.routeSelections.push(object);
                setColor(selectionInfo.routeSelections[selectionInfo.routeSelections.length-1], material);
            }

            function clearRoute() {
                $.each(selectionInfo.routeSelections, function (index, value) {
                    unsetColor(selectionInfo.routeSelections[index]);   
                });
                $.each(scene.children, function (index, value) {
                    if (value.meshType == 'line') {
                        //scene.remove(value);                        
                        value.visible = false;
                    }
                });
                selectionInfo.routeSelections = [];
                selectionInfo.currentRoute = [];
                $('#labelInfo').text('');
                displayDistance();
                displayRoute();
            }

            function handlePossibleSelection() {
                if (selectionInfo.currentIntersectingObject && selectionInfo.currentIntersectingObject.visible) {
                    var systemName = selectionInfo.currentIntersectingObject.sysInfo.system;

                    if (shiftPressed) {

                    } else {
                        applySelectionToSystem(selectionInfo, systemName, routeSelectionMaterial)
                        syncDropDown('#ddlSystemsHidden', systemName);
                    }
                }
            }

            function syncDropDown(dropDownName, systemName) {
                //$(dropDownName).val(systemName);
                //$(dropDownName).select2("data", [{id: systemName, text: systemName}]);
            }			

			function render() {

				renderer.render( scene, camera );
				stats.update();
			}

			function readXyzData() {

			    var sysInfo = [];

                // handle data already in galactic xyz co-ords
			    for (var i = 0; i < gammaData.length; i++) {
			        var parts = gammaData[i];

			        if (!isNaN(parts[1]) && !isNaN(parts[2]) && !isNaN(parts[3])) {                        
			            var newSysInfo = { "system": parts[0], "station": "", "x": +parts[1], "y": +parts[2], "z": +parts[3] };
			            sysInfo.push(newSysInfo);
			        }
			    }

			    return sysInfo;
			}


			function calculateDistance(first, second) {
			    // d = sqrt((x2-x1)^2 + (y2-y1)^2 + (z2-z1)^2)
			    if (first && second) {
			        var d = Math.sqrt(((first.x - second.x) * (first.x - second.x)) + ((first.y - second.y) * (first.y - second.y)) + ((first.z - second.z) * (first.z - second.z)));
			        return d;
			    }
			    return 0;
			}

			function setColor(mesh, material) {
			    if (mesh && mesh.material) {			        
			        mesh.material = material;
			        mesh.sisterMesh.material = mesh.material;
			    }
			}

			function unsetColor(mesh) {
			    if (mesh && mesh.material) {
			        mesh.material = unselectedMaterial;
			        mesh.sisterMesh.material = mesh.material;
			    }
			}

			function makeTextSprite(message, parameters) {
			    if (parameters === undefined) parameters = {};

			    var fontface = parameters.hasOwnProperty("fontface") ?
                    parameters["fontface"] : "Arial";

			    var fontsize = parameters.hasOwnProperty("fontsize") ?
                    parameters["fontsize"] : 18;

			    var borderThickness = parameters.hasOwnProperty("borderThickness") ?
                    parameters["borderThickness"] : 4;

			    var borderColor = parameters.hasOwnProperty("borderColor") ?
                    parameters["borderColor"] : { r: 0, g: 0, b: 0, a: 1.0 };

			    var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?
                    parameters["backgroundColor"] : { r: 255, g: 255, b: 255, a: 1.0 };

			    //var spriteAlignment = THREE.SpriteAlignment.topLeft;

			    var canvas = document.createElement('canvas');
			    var context = canvas.getContext('2d');
			    context.font = "Bold " + fontsize + "px " + fontface;

			    // get size data (height depends only on font size)
			    var metrics = context.measureText(message);
			    var textWidth = metrics.width;

			    // background color
			    context.fillStyle = "rgba(" + backgroundColor.r + "," + backgroundColor.g + ","
                                              + backgroundColor.b + "," + backgroundColor.a + ")";
			    // border color
			    context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + ","
                                              + borderColor.b + "," + borderColor.a + ")";

			    context.lineWidth = borderThickness;
			    roundRect(context, borderThickness / 2, borderThickness / 2, textWidth + borderThickness, fontsize * 1.4 + borderThickness, 6);
			    // 1.4 is extra height factor for text below baseline: g,j,p,q.

			    // text color
			    context.fillStyle = "rgba(0, 0, 0, 1.0)";

			    context.fillText(message, borderThickness, fontsize + borderThickness);

			    // canvas contents will be used for a texture
			    var texture = new THREE.Texture(canvas)
			    texture.needsUpdate = true;

			    //var spriteMaterial = new THREE.SpriteMaterial({ map: texture, useScreenCoordinates: false, alignment: spriteAlignment });
			    var spriteMaterial = new THREE.SpriteMaterial({ map: texture, useScreenCoordinates: false});//, alignment: spriteAlignment });
			    var sprite = new THREE.Sprite(spriteMaterial);
			    sprite.scale.set(100, 50, 1.0);
			    return sprite;
			}

			// function for drawing rounded rectangles
			function roundRect(ctx, x, y, w, h, r) {
			    ctx.beginPath();
			    ctx.moveTo(x + r, y);
			    ctx.lineTo(x + w - r, y);
			    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
			    ctx.lineTo(x + w, y + h - r);
			    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
			    ctx.lineTo(x + r, y + h);
			    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
			    ctx.lineTo(x, y + r);
			    ctx.quadraticCurveTo(x, y, x + r, y);
			    ctx.closePath();
			    ctx.fill();
			    ctx.stroke();
			}

		</script>
	</body>
</html>